---
title: "[자율 공부방] 학습(작업) 내용 공유 - 14"
toc: false
tags: [영남이공대학교, 자율 공부방]
categories:
  - Daily
  - SelfStudy
date: 2020-09-17 23:53:00
thumbnail: /images/post_include/daily_self-study/title.gif
---
> 영남이공대학교 자율 공부 모임에 공유할 목적으로 작성하는 포스트입니다.  
> 학습 내용에 대한 구체적인 사항은 별도 포스트에서 다룰 예정입니다.
> 개인적으로 학습하며 기록하고 있기 때문에 <font color='red'>잘못된 내용</font>이 있을 수 있습니다. 잘못된 내용이 있다면 댓글로 알려주세요.  

# 개요
* 날짜: 2020년 09월 17일 목요일
* 내용: 교과목 운영체제 강의를 듣고 관련 내용을 정리하며 학습하고, 컴퓨터정보과 프로젝트 모임 회의를 진행했습니다.

# 교과 학습 - 운영체제
## 프로세스의 정의
> 1960년대 멀틱스(multics) 운영체제에서 처음 사용

* IBM 운영체제에서의 작업(task)
* 실행 중인 프로그램 (가장 일반적인 정의)
* 프로세서에 할당하여 실행할 수 있는 개체 dispatch 가능한 대상
    * 다음에 실행해야 하는 프로그램을 dispatcher 에 알려주는 액션(Dispatch)
    
## 사용자 관점의 프로세스: 프로세스의 일반적인 메모리 구조
* 스택: 지역 변수, 함수 저장
* 힙: 코드 영역과는 별도로 유지되는 자유 메모리 공간 => 동적 할당된 메모리 저장
* 데이터: 전역 변수 저장, 프로그램의 가상 주소 공간
* 코드: 실행 명령을 포함하는 메모리이거나 목적 파일에 있는 프로그램 영역
    * 프로그램 포인터
    * 변하지 않음(Read-Only)

## 시스템 관점의 프로세스
* 스케줄러: 실행 순서 결정한다.
* 보호: 일반 프로세스가 CPU나 하드웨어와 관련된 OS 메모리를 건들면 안된다.
* 교착상태: 프로세스가 공유 자원에 접근할 때 교착이 발생할 수 있다.

## 프로세스의 상태 처리
* 생성 상태
    * Job Queue
    * Job Scheduler에 의해서 준비 상태로 변경
* 준비 상태
    * Ready Queue
    * CPU Scheduler에 의해서 실행할 프로세스 결정(Dispatcher에게 실행해야 하는 PID를 알려줌)
* 실행 상태
    * 실행하다가 I/O나 Interrupt를 만나면, 더 이상 연산 수행 불가
    * I/O나 Interrupt를 사용하기 위해서 대기 상태로 전환
    * Time Sharing System에서 할당된 시간이 종료되면 준비 상태로 전환
* 대기 상태
    * Device Queue
    * Device Scheduler가 Device Queue를 감지하여 I/O나 Interrupt 수행
    * I/O나 Interrupt를 마치면 준비 단계로 전환

### Scheduler
* Job Scheduler: 장기 스케쥴러 / 생성 상태 => 준비 상태
* CPU Scheduler: 단기 스케쥴러 / 준비 상태 => 실행 상태
* Device Scheduler: 중기 스케쥴러 / 대기 상태 => 준비 상태

## 프로세스의 상태 변화
* 준비=>실행: dispatch
* 실행=>준비: timeout
* 실행=>대기: block
* 대기=>준비: wakeup

## PCB
### 구성요소
> 프로세스 식별자, 프로세스 상태, 프로그램 카운터, 레지스터 저장 영역, 프로세서 스케줄링 정보, 계정 정보, 입출력 상태정보, 메모리 관리 정보, ...

### 프로세스의 문맥 교환(Process Context Switch)
* 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것
* 프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용 저장

## 토론
### 프로그램 코드가 저장되는 코드 부분이 읽기 전용인 이유는?
코드 영역에는 프로그래머가 작성한 코드(함수, 변수, 로직 등)를 기계어로 바꾼 내용이 저장됩니다.

만약 이러한 내용이 변경가능하다면, 기존에 설계한 작동과 다르게 프로그램이 작동할 것입니다.

또한 보안적으로도 취약해질 수 있기 때문에, 이 영역은 Read-Only라고 생각합니다.

### PCB는 운영체에서 어떤 구조로 구현하는 것이 좋을까?
운영체제는 PCB를 이용해 프로세스의 상태 정보를 관리합니다.
여러 프로세스가 동시에 메모리에 적재되어 실행될 수 있기 때문에, PCB의 개수도 다양합니다.

이러한 PCB를 관리하기 위해서는 단순히 Array를 사용하는 방법이 있을 것입니다. 그러나 프로세스가 종료되면 PCB도 종료되어야 합니다.
즉, Array에서 중간 데이터를 삭제 해야 하는 것입니다. Array에서 중간 데이터를 삭제하는 경우 전체 탐색 시 Null 관련 Exception이 발생할 수 있으며 이를 방지하기 위해선 또 다른 작업이 요구됩니다.

그리고 새로운 PCB의 삽입과 기존 PCB의 삭제를 위해 빈번하게 동적할당을 하는 등 비효율적일 것입니다.

이에 운영체제에서는 일반적으로 링크드 리스트를 사용하여 위의 단점을 보완하고 있다고 생각합니다.

# 컴퓨터정보과 프로젝트 모임
* 구성원 소개
* 모임의 방향성, 형태, 목표 논의
* 모임의 명칭: 지속적인 논의 예정
* 프로젝트 아이디어 발굴(3건)