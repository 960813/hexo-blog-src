---
title: "[컴퓨터구조론 개정5판] 04장 기본문제 풀이 - 생능출판(김종현 저)"
toc: false
tags: [컴퓨터구조론,생능출판]
categories:
  - Book
  - Review
date: 2020-06-29 04:00:00
thumbnail: /images/post_include/computer-architecture/book_poster.jpg
---
> 2019년 8월 12일 인쇄된 생능 출판의 김종현 저 컴퓨터구조론 제5판2쇄를 기준으로 작성되었습니다.  
> 저작권법 등의 문제로 문제를 제외한 답과 풀이만을 제공합니다.  
> 개인적으로 학습하며 풀이하였기때문에 <font color='red'>틀린 답</font>이 있을 수 있습니다. 잘못된 내용이 있다면 댓글로 알려주세요.  

# 04장 기본문제: P.223 ~ 224
## **기본문제 4.1**
* 정답: 나. CAR
* 풀이: CAR(Control Address Register)는 제어 유니트에서 다음에 실행할 마이크로명령어의 주소를 가지고 있다.

## **기본문제 4.2**
* 정답: 다. ROM
* 풀이: 제어 기억장치는 마이크로명령어들로 이루어진 마이크로 프로그램을 저장해둔 내부 기억장치로 ROM(Read Only Memory)에 사전 정의되어 있다.

## **기본문제 4.3**
* 정답: 다. 점프(JUMP)
* 풀이: SBR은 SubRoutine 호출시 작동이 종료된 후 본래의 프로그램으로 돌아가기 위해 기존의 명령어 주소(CAR)를 저장한다. JUMP 명령어는 분기된 이후 돌아가지 않기 때문에 SBR을 사용하지 않는다.

## **기본문제 4.4**
* 정답: 가. 0xxx000
* 풀이: 
    1. 용량이 128단어이기 때문에 명령어는 7bit(2<sup>7</sup>=128)로 구성되어야 한다.
    2. 최대 8개의 마이크로명령어를 구성하기 위해선 op-code가 3bit(2<sup>3</sup>=8) 필요하다.
    3. 처음 절반 부분에 실행 사이클 루틴을 저장하기 때문에 0으로 시작한다.(마지막 절반 부분에 저장한다면 1로 시작)
    4. 0xxx000(처음 절반: 0, op-code: xxx, 7bit를 맞추기 위한 padding: 000)
    
## **기본문제 4.5**
* 정답: 나. CAR ← ADF
* 풀이: 조건부 호출 마이크로-연산 실행 시
    - 조건 만족: CAR ← ADF
    - 조건 만족 x: CAR ← CAR + 1

## **기본문제 4.6**
* 정답: 다. CAR ← SBR
* 풀이: RET는 CALL 이후 수행된다. CALL 호출 시 현재 CAR을 SBR에 저장하고 RET시 SBR을 CAR에 저장하여 원래의 프로그램으로 복귀한다. 

## **기본문제 4.7**
* 정답: 다. 연산 필드 비트들
* 풀이: 연산 필드 비트들은 IR(명령어 레지스터)에서 명령어 해독기로 전달된다. 명령어 해독기는 해당 비트를 해독해 CAR에 연산을 수행하기 위한 명령어의 주소를 적재한다. 

## **기본문제 4.8**
* 정답: 나. 8개
* 풀이: 4개 + 4개 = 8개
    - 수평적 마이크로프로그래밍?
        - 개요
            1. 연산 필드의 비트와 제어 신호를 1:1로 대응
            2. 그 수 만큼의 마이크로 명령어들 사용
        - 특징
            1. 해독기를 통하지 않아 하드웨어가 간단하고 해독에 따른 지연이 없다.
            2. 연산 필드의 비트 수가 필요한 제어 신호의 수만큼 제공되어야 해서 마이크로 명령어의 길이가 길고, 제어 기억장치의 용량이 커진다는 단점이 있다.

## **기본문제 4.9**
* 정답: 다. 32개
* 풀이: 2<sup>4</sup> + 2<sup>4</sup> = 32개
    - 수직적 마이크로프로그래밍?
        - 개요
            1. 해독기(decoder) 이용
            2. 적은 수의 코드화된(encoded) 비트들을 포함하여 명령어 길이가 짧음
            3. 외부해독기를 통해 원하는 수 만큼 신호를 확장
        - 특징
            1. 명령어 길이가 짧아 기억장치 용량이 적게 요구됨.
            2. 해독기를 통하는 과정에서 지연 시간 발생

## **기본문제 4.10**
* 정답: 라. 제어 신호의 발생을 위한 추가적 하드웨어가 필요하지 않다.
* 풀이: 수평적 마이크로프로그래밍은 해독기(decoder)를 사용하지 않기 때문에 이에 부합되는 장점이다.

## **기본문제 4.11**
* 정답: 나. 13
* 풀이: k-단계 파이프라인에서 n개의 명령어들을 실행하는 데 소요되는 사이클은 k + (n - 1)이다. 즉, 4 + (10 - 1) = 13

## **기본문제 4.12**
* 정답: 다. 4개
* 풀이: k-way 슈퍼스칼라는 매 사이클마다 k개의 명령어를 실행한다.

## **기본문제 4.13**
* 정답: 다. S 플래그
* 풀이: 음수인지 검사해야 하기에 부호를 확인해야 한다. 부호 상태를 나타내는 조건 비트는 S 플래그(음수: 1, 양수: 0)이다. Z 플래그: 결과 값이 0인지 나타내는 비트 / E 플래그: 두 수를 비교한 결과가 동일한지 나타내는 비트 / V 플래그: 연산 결과 Overflow가 발생했는지 나타내는 비트

## **기본문제 4.14**
* 정답: 라. 호출할 주소를 스택으로부터 인출한다.
* 풀이: 호출할 주소는 주기억장치로부터 인출한다.

## **기본문제 4.15**
* 정답: 라. 16KByte
* 풀이: 오퍼랜드 필드가 14비트이므로 2<sup>14</sup>개의 기억장치 주소를 지정할 수 있다. 2<sup>4</sup> x 2<sup>10</sup> x 8bit = 16KByte

## **기본문제 4.16**
* 정답: 나. 5비트
* 풀이: 32개의 레지스터를 지정하기 위해서는 5비트가 필요하다. 2<sup>5</sup> = 32

## **기본문제 4.17**
* 정답: 나. 프로그램 길이가 짧아진다.
* 풀이: 3-주소 명령어는 한 명령어에 많은 의미를 포함하기 때문에 프로그램의 전체적인 길이는 짧아진다.
    - 1-주소 명령어: [연산코드] + [오퍼랜드] : ADD X
    - 2-주소 명령어: [연산코드] + [오퍼랜드1] + [오퍼랜드2] : ADD R1, R2
    - 3-주소 명령어: [연산코드] + [오퍼랜드1] + [오퍼랜드2] + [오퍼랜드3] : ADD R1, R2, R3

## **기본문제 4.18**
* 정답: 나. 두 번
* 풀이: 1) 오퍼랜드에 지정된 주소에서 실제 데이터의 주소 인출 2) 실제 데이터의 주소에서 데이터를 인출 

## **기본문제 4.19**
* 정답: 다. AC
* 풀이: 묵시적 주소지정 방식을 사용하는 산술 명령어에는 SHIFT X, ADD X 등이 있다. 이들은 AC의 값을 기반으로 작동한다.

## **기본문제 4.20**
* 정답: 다. 116번지
* 풀이: 현재 실행되고 있는 명령어의 위치가 130번지이면 PC에는 131번지가 저장되어 있을 것이다. 상대 주소지정 방식을 사용하는 분기 명령어 'JR -15'는 PC의 값에서 변위(-15)를 더한 위치로 분기하는 명령어이다. 131 + (-15) = 116

## **기본문제 4.21**
* 정답: 나. 주소지정 방식이 매우 다양하다.
* 풀이:
    - RISC 프로세서의 특징(새로운 개념)
        1. 명령어의 수 최소화
        2. 명령어의 길이 고정
        3. 주소지정 방식의 종류 단순화
    - CISC 프로세서의 특징(기존 유형의 프로세서)
        1. 복잡한 명령어 형식